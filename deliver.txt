Projeto 2 - Software a ser testado.

Composição do grupo:
-Bruno Sequeira nº 2020235721
-Rui Santos nº 2020225542 
PL2
Temos cerca de 3 códigos:

Iremo-nos focar nos 2 primeiros, o ultimo fica em 'stand-by'.

Este código em Java implementa um solver para o jogo Sudoku. Ele utiliza uma técnica de backtracking para tentar preencher o tabuleiro de Sudoku de forma válida, ou seja, respeitando todas as regras do jogo.

A função em estudo é: solve.

import java.util.*;
public class code {

    static char[][] board = {
        {'5', '3', '.', '.', '7', '.', '.', '.', '.'},
        {'6', '.', '.', '1', '9', '5', '.', '.', '.'},
        {'.', '9', '8', '.', '.', '.', '.', '6', '.'},
        {'8', '.', '.', '.', '6', '.', '.', '.', '3'},
        {'4', '.', '.', '8', '.', '3', '.', '.', '1'},
        {'7', '.', '.', '.', '2', '.', '.', '.', '6'},
        {'.', '6', '.', '.', '.', '.', '2', '8', '.'},
        {'.', '.', '.', '4', '1', '9', '.', '.', '5'},
        {'.', '.', '.', '.', '8', '.', '.', '7', '9'}
    };

    public static void solveSudoku(char[][] board) {
        solve(board);
    }
    public static boolean solve(char[][]board){
        for(int i=0;i<9;i++){
            for(int j=0;j<9;j++){

                if(board[i][j]=='.'){

                    for(char num='1';num<='9';num++){
                        if(isPossible(board,i,j,num)){
                            board[i][j]=num;
                            if(solve(board)){
                                return true;
                            }
                            //if the solve function return false then the prev num must be in wrong pos so then backtrack
                            //and fill that with '.'. 
                            else{
                                board[i][j]='.';
                            }
                        }
                    }

                    //if it is not possible to select a number from 1 to 9 the solve function return false;
                    return false;
                }
            }
        }
        return true;
    }

    public static boolean isPossible(char[][]board,int row,int col,char c){
        for(int i=0;i<9;i++){
            if(board[i][col]==c) return false;//col check

            if(board[row][i]==c) return false; //row check

            if(board[3*(row/3)+i/3][3*(col/3)+i%3]==c) return false;//checking in each 3 x 3 matrix
        }
        return true;

    }

    public static void main(String[] args){

        solveSudoku(board);
        for (int i = 0; i < 9; i++) {
            for (int j = 0; j < 9; j++) {
                System.out.print(board[i][j] + " ");
            }
            System.out.println();
        }
        
    }

}





###################################################################################################################################################################################################################


Este código implementa o algoritmo de Dijkstra para encontrar o caminho mais curto em um grafo ponderado direcionado.

A função em estudo é "dijkstra"

class Vertex {
    public int id;
    public int distance;

    public Vertex(int id) {
        this.id = id;
        this.distance = Integer.MAX_VALUE;
    }
}

class Edge {
    public int source;
    public int destination;
    public int weight;

    public Edge(int source, int destination, int weight) {
        this.source = source;
        this.destination = destination;
        this.weight = weight;
    }
}

class Graph {
    public Map<Integer, List<Edge>> adjacencyList;

    public Graph(int numVertices) {
        this.adjacencyList = new HashMap<>();
        for (int i = 0; i < numVertices; i++) {
            adjacencyList.put(i, new ArrayList<>());
        }
    }

    public void addEdge(int source, int destination, int weight) {
        List<Edge> edges = adjacencyList.get(source);
        edges.add(new Edge(source, destination, weight));
    }

    public List<Edge> getEdges(int vertex) {
        return adjacencyList.get(vertex);
    }
}

public class Dijkstra {
    public static void main(String[] args) {
        int numVertices = 5;
        Graph graph = new Graph(numVertices);
        graph.addEdge(0, 1, 10);
        graph.addEdge(0, 2, 5);
        graph.addEdge(1, 2, 2);
        graph.addEdge(1, 3, 1);
        graph.addEdge(2, 1, 3);
        graph.addEdge(2, 3, 9);
        graph.addEdge(2, 4, 2);
        graph.addEdge(3, 4, 4);
        graph.addEdge(4, 0, 7);

        int sourceVertex = 0;
        int[][] distance =  dijkstra(graph, sourceVertex);
        for(int i = 0; i < distance.length; i++){
            System.out.printf("%d - %d\n",distance[i][0],distance[i][1]);
        }
    }

    public static int[][] dijkstra(Graph graph, int source) {
        
        int numVertices = graph.adjacencyList.size();
        boolean[] visited = new boolean[numVertices];
        PriorityQueue<Vertex> priorityQueue = new PriorityQueue<>(numVertices, Comparator.comparingInt(v -> v.distance));
        Vertex[] vertices = new Vertex[numVertices];

        for (int i = 0; i < numVertices; i++) {
            vertices[i] = new Vertex(i);
            if (i == source) {
                vertices[i].distance = 0;
            }
            priorityQueue.add(vertices[i]);
        }

        while (!priorityQueue.isEmpty()) {
            Vertex currentVertex = priorityQueue.poll();
            visited[currentVertex.id] = true;

            List<Edge> edges = graph.getEdges(currentVertex.id);
            for (Edge edge : edges) {
                if (!visited[edge.destination]) {
                    int newDistance = currentVertex.distance + edge.weight;
                    if (newDistance < vertices[edge.destination].distance) {
                        priorityQueue.remove(vertices[edge.destination]);
                        vertices[edge.destination].distance = newDistance;
                        priorityQueue.add(vertices[edge.destination]);
                    }
                }
            }
        }
        int[][] distance = new int[vertices.length][2];
        int count = 0;
        for (Vertex vertex : vertices) {
            distance[count][0] = vertex.id;
            distance[count][1] = vertex.distance;
            count++;
           // System.out.println(vertex.id + " \t\t " + vertex.distance);
        }
        return distance;
    }

    public static void printSolution(Vertex[] vertices) {
        System.out.println("Vertex \t Distance from Source");
        for (Vertex vertex : vertices) {
            System.out.println(vertex.id + " \t\t " + vertex.distance);
        }
    }
}
#############################################################################################################


FUNÇÃO STAND-BY
Esta código encontra os tripletes de um array. 




public class CodeJava  
{ 
  
    // function to print triplets with 0 sum 
    public static int[][] findTriplets(int arr[], int n)  
    { 
        boolean found = false; 
        int[][] result = new int[n*3][3];
        int count = 0;
        for (int i = 0; i < n - 1; i++)  
        { 
            // Find all pairs with sum equals to 
            // "-arr[i]" 
            HashSet<Integer> s = new HashSet<Integer>(); 
            for (int j = i + 1; j < n; j++)  
            { 
                int x = -(arr[i] + arr[j]); 
                if (s.contains(x))  
                { 
                    result[count][0] = x;
                    result[count][1] = arr[i];
                    result[count][2] = arr[j];
                    count++;
                    found = true; 
                }  
                else 
                { 
                    s.add(arr[j]); 
                } 
            } 
        } 
  
        
        return result;
    } 
  
    // Driver code 
    public static void main(String[] args)  
    { 
        int arr[] = {0, -1, 2, -3, 1}; 
        int n = arr.length; 
        int[][] result = findTriplets(arr, n); 
        for(int i = 0; i < result.length;i++){
            System.out.printf("%d %d %d\n",result[i][0],result[i][1],result[i][2]);
        }
    } 
} 
